#!@PERL@
# BEGIN BPS TAGGED BLOCK {{{
#
# COPYRIGHT:
#
# This software is Copyright (c) 1996-2023 Best Practical Solutions, LLC
#                                          <sales@bestpractical.com>
#
# (Except where explicitly superseded by other copyright notices)
#
#
# LICENSE:
#
# This work is made available to you under the terms of Version 2 of
# the GNU General Public License. A copy of that license should have
# been provided with this software, but in any event can be snarfed
# from www.gnu.org.
#
# This work is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301 or visit their web page on the internet at
# http://www.gnu.org/licenses/old-licenses/gpl-2.0.html.
#
#
# CONTRIBUTION SUBMISSION POLICY:
#
# (The following paragraph is not intended to limit the rights granted
# to you to modify and distribute this software under the terms of
# the GNU General Public License and is only of importance to you if
# you choose to contribute your changes and enhancements to the
# community by submitting them to Best Practical Solutions, LLC.)
#
# By intentionally submitting any modifications, corrections or
# derivatives to this work, or any other work intended for use with
# Request Tracker, to Best Practical Solutions, LLC, you confirm that
# you are the copyright holder for those contributions and you grant
# Best Practical Solutions,  LLC a nonexclusive, worldwide, irrevocable,
# royalty-free, perpetual, license to use, copy, create derivative
# works based on those contributions, and sublicense and distribute
# those contributions and any derivatives thereof.
#
# END BPS TAGGED BLOCK }}}
use warnings;
use strict;

BEGIN { # BEGIN RT CMD BOILERPLATE
    require File::Spec;
    require Cwd;
    my @libs = ("@RT_LIB_PATH@", "@LOCAL_LIB_PATH@");
    my $bin_path;

    for my $lib (@libs) {
        unless ( File::Spec->file_name_is_absolute($lib) ) {
            $bin_path ||= ( File::Spec->splitpath(Cwd::abs_path(__FILE__)) )[1];
            $lib = File::Spec->catfile( $bin_path, File::Spec->updir, $lib );
        }
        unshift @INC, $lib;
    }

}

use Getopt::Long;
use RT;
use RT::Interface::CLI qw( loc );
use RT::Interface::Email;

RT::LoadConfig();
RT::Init();

sub usage {
    my ($error) = @_;
    print loc("Usage:") . " $0 --expired-by date [--print] [--help]\n";
    print "\n" . loc(
        "[_1] is a utility, meant to be run from cron, that emails all users with a list of their auth tokens that will expire by the expired-by date.",
        $0
    ) . "\n";
    print "\t--expired-by date\t"
        . loc("Include all auth tokens that will expire by date.")
        . "\n"
        . "\t                 \t"
        . loc("Date can be in any format understood by Time::ParseDate.")
        . "\n";
    print "\t-p, --print      \t"
        . loc("Print the expiring auth tokens to STDOUT; don't email them.");
    print "\t-h, --help       \t" . loc("Print this message") . "\n";

    if ( $error eq 'help' ) {
        exit 0;
    } else {
        print loc("Error") . ": " . loc($error) . "\n";
        exit 1;
    }
}

my ( $expiredBy, $print, $help ) = ( '', '', '' );
GetOptions(
    'expired-by=s' => \$expiredBy,
    'print'        => \$print,
    'help'         => \$help,
);

usage('help') if $help;
usage("expired-by parameter is required")
    unless $expiredBy;

my $expiredByDateObj = RT::Date->new( RT->SystemUser );
usage("Invalid date parameter '$expiredBy'")
    unless $expiredByDateObj->Set( Format => 'unknown', Value => $expiredBy ) > 0;

my $authTokens = RT::AuthTokens->new( RT->SystemUser );
$authTokens->Limit(
    FIELD           => 'Expires',
    VALUE           => $expiredByDateObj->ISO(),
    OPERATOR        => '<=',
    ENTRYAGGREGATOR => 'AND',
);
$authTokens->Limit(
    FIELD           => 'Expires',
    VALUE           => 'NULL',
    OPERATOR        => 'IS NOT',
    ENTRYAGGREGATOR => 'AND',
);

my %expiredTokensByUser = ();
while ( my $row = $authTokens->Next ) {
    $expiredTokensByUser{ $row->Owner } = [
        @{ $expiredTokensByUser{ $row->Owner } || [] },
        {
            desc    => $row->Description,
            expires => $row->Expires
        }
    ];
}

# Load our template.  If we cannot load the template, abort
# immediately rather than failing through many loops.
my $token_template = RT::Template->new( RT->SystemUser );
my ( $ret, $msg ) = $token_template->Load('Email Auth Token Expiry');
unless ($ret) {
    print loc("Failed to load template")
        . " 'Email Auth Token Expiry': "
        . $msg
        . ".  Cannot continue.\n";
    exit 1;
}

foreach my $userId ( keys %expiredTokensByUser ) {
    my $userObj = RT::User->new( RT->SystemUser );
    my ( $ret, $msg ) = $userObj->Load($userId);
    if ( $ret ) {
        my $userName     = $userObj->RealName || $userObj->Name;
        my $userEmail    = $userObj->EmailAddress;
        my $emailContent = $print ? "Expiring Auth Tokens for '$userName':\n"
                                  : "Hello, $userName.\n\nThe following auth tokens will expire by " . $expiredByDateObj->Date . ":\n\n";
        foreach my $authToken ( @{ $expiredTokensByUser{$userId} } ) {
            $emailContent .= $print ? "\t" : "";
            $emailContent .= $authToken->{desc} . ' expires on ' . $authToken->{expires} . "\n";
        }

        if ( $print ) {
            print "$emailContent\n";
        } else {
            unless ( $userEmail ) {
                RT->Logger->warning( loc("No email for User") . ": $userName" );
                next;
            }
            ( $ret, $msg ) = $token_template->Parse( Argument => $emailContent );
            unless ($ret) {
                print loc("Failed to parse template")
                    . " 'Email Auth Token Expiry'.  Cannot continue.\n";
                exit 1;
            }

            # Set our sender and recipient.
            $token_template->MIMEObj->head->replace(
                'From', Encode::encode( "UTF-8", RT::Config->Get('CorrespondAddress') ) );
            $token_template->MIMEObj->head->replace(
                'To',   Encode::encode( "UTF-8", $userEmail ) );

            my $ok = RT::Interface::Email::SendEmail(
                Entity => $token_template->MIMEObj );

            if ( ! $ok ) {
                RT->Logger->error("Failed to send expiring auth tokens email to $userEmail");
            }
        }

    } else {
        RT->Logger->error("Could not load User with id $userId: $msg");
    }
}


__END__

=head1 NAME

rt-email-expiring-auth-tokens - email users about expiring auth tokens

=head1 SYNOPSIS

    rt-email-expiring-auth-tokens --expired-by Expire-By-Date [--print] [--help]

=head1 DESCRIPTION

This script is a tool to email users about their expiring auth tokens.

=head1 OPTIONS

=over

=item expired-by

Any auth tokens that expire by this date will be included in the email.

Format is YYYY-MM-DD.

=item print

Print the expiring auth tokens to STDOUT; don't email them.

=item help

Print this message

=back
